// application/hooks/useAuth.ts
import { container } from 'tsyringe';
import { useState, useEffect, useCallback } from 'react';
import { IAuthRepository } from '@/domain/repository/IAuthRepository';
import { IWalletRepository } from '@/domain/interfaces/repository/IWalletRepository';
import { IAuthStateRepository } from '@/domain/repository/IAuthStateRepository';
import { User } from '@/domain/models/User';
import { UserRegistrationVo } from '@/domain/valueObjects/UserRegistrationVo';
import { AuthStorageService } from '@/infrastructure/storage/modules/AuthStorageService';

import {Wallet} from "@/domain/entities/Wallet";

class AuthManager {
  private static instance: AuthManager;
  private authRepository: IAuthRepository;
  private walletRepository: IWalletRepository;
  private authStateRepository: IAuthStateRepository;
  private listeners: Set<() => void> = new Set();
  private isInitializing = false;
  private hasInitialized = false;
  
  // ‚úÖ NUEVO: Control de estabilidad
  private isStabilizing = false;
  private stabilizationTimeout: NodeJS.Timeout | null = null;
  private lastAuthChange = 0;
  private firebaseUnsubscribe: (() => void) | null = null;
  
  public state = {
    user: null as User | null,
    loading: true,
    error: null as string | null,
    isInitialized: false,
  };

  private constructor() {
    this.authRepository = container.resolve<IAuthRepository>('IAuthRepository');
    this.authStateRepository = container.resolve<IAuthStateRepository>('IAuthStateRepository');

    this.walletRepository = container.resolve<IWalletRepository>('IWalletRepository');
  }

  static getInstance(): AuthManager {
    if (!AuthManager.instance) {
      AuthManager.instance = new AuthManager();
    }
    return AuthManager.instance;
  }

  subscribe(listener: () => void): () => void {
    this.listeners.add(listener);
    
    if (!this.hasInitialized && !this.isInitializing) {
      this.initialize();
    }
    
    return () => {
      this.listeners.delete(listener);
    };
  }

  private notify() {
    // ‚úÖ NUEVO: Solo notificar si no est√° estabilizando
    if (!this.isStabilizing) {
      this.listeners.forEach(listener => listener());
    }
  }

  private updateState(updates: Partial<typeof this.state>) {
    this.state = { ...this.state, ...updates };
    this.notify();
  }

  // ‚úÖ NUEVO: Actualizaci√≥n estable con debounce
  private stableUpdateState(updates: Partial<typeof this.state>, delay: number = 300) {
    // Cancelar timeout anterior
    if (this.stabilizationTimeout) {
      clearTimeout(this.stabilizationTimeout);
    }

    // Marcar como estabilizando
    this.isStabilizing = true;
    
    // Aplicar cambios despu√©s del delay
    this.stabilizationTimeout = setTimeout(() => {
      this.state = { ...this.state, ...updates };
      this.isStabilizing = false;
      this.notify();
    }, delay);
  }

  private async initialize() {
    if (this.isInitializing || this.hasInitialized) return;
    
    try {
      this.isInitializing = true;
      console.log('üîÑ Inicializando auth...');
      
      // Inicializar SQLite
      await AuthStorageService.init();
      
      // Verificar sesi√≥n local primero (m√°s r√°pido)
      await AuthStorageService.cleanupOrRefresh();
      const sessionInfo = await AuthStorageService.getSessionInfo();
      
      if (sessionInfo.isAuthenticated && sessionInfo.user && !sessionInfo.sessionExpired) {
        console.log('‚úÖ Sesi√≥n local v√°lida - estableciendo usuario inmediatamente');
        
        // ‚úÖ CAMBIO: Establecer usuario inmediatamente sin esperas
        this.updateState({
          user: sessionInfo.user,
          loading: false,
          isInitialized: true,
        });
        
        // ‚úÖ NUEVO: Configurar Firebase listener DESPU√âS de establecer estado local
        setTimeout(() => this.setupFirebaseListener(true), 100);
        
      } else {
        console.log('‚ùå Sin sesi√≥n local v√°lida');
        await AuthStorageService.clearAuthData();
        
        // ‚úÖ CAMBIO: Configurar Firebase listener inmediatamente
        this.setupFirebaseListener(false);
      }
    } catch (error) {
      console.error('üí• Error inicializando:', error);
      await AuthStorageService.clearAuthData();
      this.setupFirebaseListener(false);
    } finally {
      this.isInitializing = false;
      this.hasInitialized = true;
    }
  }

  // ‚úÖ MEJORADO: Firebase listener con control de parpadeo
  private setupFirebaseListener(hasLocalSession: boolean) {
    console.log('üëÇ Configurando Firebase listener...', { hasLocalSession });
    
    // Limpiar listener anterior si existe
    if (this.firebaseUnsubscribe) {
      this.firebaseUnsubscribe();
    }
    
    this.firebaseUnsubscribe = this.authStateRepository.onAuthStateChanged(async (userData) => {
      const now = Date.now();
      
      // ‚úÖ NUEVO: Evitar cambios muy frecuentes
      if (now - this.lastAuthChange < 500) {
        console.log('üö´ Cambio de auth ignorado - muy frecuente');
        return;
      }
      this.lastAuthChange = now;
      
      console.log('üî• Firebase auth cambi√≥:', { hasUser: !!userData, userId: userData?.id });
      
      if (userData) {
        // ‚úÖ CAMBIO: Verificar si ya tenemos este usuario localmente
        const currentUser = this.state.user;
        if (currentUser && currentUser.id === userData.id) {
          console.log('‚úÖ Usuario ya establecido localmente - solo refrescando');
          await AuthStorageService.refreshSession();
          return;
        }
        
        // Usuario nuevo o diferente
        console.log('üì± Guardando usuario desde Firebase');
        await AuthStorageService.saveUser(userData);
        
        // ‚úÖ NUEVO: Si ya hab√≠a sesi√≥n local, usar actualizaci√≥n estable
        if (hasLocalSession && this.state.user) {
          this.stableUpdateState({ user: userData }, 100);
        } else {
          this.updateState({ user: userData });
        }
        
      } else {
        // Sin usuario en Firebase
        console.log('üö™ Firebase sin usuario - limpiando');
        await AuthStorageService.clearAuthData();
        
        // ‚úÖ NUEVO: Solo actualizar si realmente hab√≠a un usuario
        if (this.state.user) {
          this.stableUpdateState({ user: null }, 200);
        }
      }
      
      // ‚úÖ CAMBIO: Marcar como inicializado solo al final
      if (!this.state.isInitialized) {
        this.updateState({ loading: false, isInitialized: true });
      }
    });
  }

  async register(userData: UserRegistrationVo) {
    try {
      this.updateState({ loading: true, error: null });
      const newUser = await this.authRepository.register(userData);

      await AuthStorageService.saveUser(newUser);
      await AuthStorageService.saveLoginMethod('email');
      
      const objWallet: Wallet = {
        name: "Billetera Principal",
        description: "Esta billetera concentra tus gastos y egresos, mostrando tu estado financiero actual en efectivo y cuentas bancarias.",
        _idType: 1,
        _idAssetType: 1,
        balance: 0,
        currency: "PEN",
        isPrimary: true,
        createdAt: new Date()
      }

      await this.walletRepository.register(newUser.id, objWallet);

      this.updateState({ user: newUser, loading: false });
    } catch (err: any) {
      this.updateState({ error: err.message, loading: false });
      throw err;
    }
  }

  async login(email: string, password: string) {
    try {
      this.updateState({ loading: true, error: null });
      const userData = await this.authRepository.login(email, password);
      
      // ‚úÖ CAMBIO: Guardar en SQLite primero, antes que Firebase notifique
      await AuthStorageService.saveUser(userData);
      await AuthStorageService.saveLoginMethod('email');
      
      // ‚úÖ NUEVO: Establecer usuario inmediatamente
      this.updateState({ user: userData, loading: false });
      
      console.log('‚úÖ Login completado - usuario establecido');
    } catch (err: any) {
      this.updateState({ error: err.message, loading: false });
      throw err;
    }
  }

  async logout() {
    try {
      this.updateState({ loading: true });
      
      // ‚úÖ CAMBIO: Limpiar local primero
      await AuthStorageService.clearAuthData();
      
      // ‚úÖ NUEVO: Establecer estado inmediatamente
      this.updateState({ user: null, loading: false });
      
      // Firebase logout en background
      this.authRepository.logout().catch(err => {
        console.warn('‚ö†Ô∏è Error en logout de Firebase:', err);
      });
      
      console.log('üö™ Logout completado');
    } catch (err: any) {
      this.updateState({ error: err.message, loading: false });
      await AuthStorageService.clearAuthData();
      this.updateState({ user: null });
    }
  }

  async checkIsGoogleUser(): Promise<boolean> {
    try {
      const loginMethod = await AuthStorageService.getLoginMethod();
      if (loginMethod === 'google') return true;
      return await this.authRepository.isGoogleUser();
    } catch {
      return false;
    }
  }

  // ‚úÖ NUEVO: M√©todo para forzar estabilizaci√≥n
  forceStabilize() {
    if (this.stabilizationTimeout) {
      clearTimeout(this.stabilizationTimeout);
      this.isStabilizing = false;
      this.notify();
    }
  }

  // ‚úÖ NUEVO: Cleanup al destruir
  destroy() {
    if (this.firebaseUnsubscribe) {
      this.firebaseUnsubscribe();
    }
    if (this.stabilizationTimeout) {
      clearTimeout(this.stabilizationTimeout);
    }
    this.listeners.clear();
  }
}

export const useAuth = () => {
  const [, forceUpdate] = useState({});
  const authManager = AuthManager.getInstance();

  const rerender = useCallback(() => {
    forceUpdate({});
  }, []);

  useEffect(() => {
    return authManager.subscribe(rerender);
  }, [rerender]);

  // ‚úÖ NUEVO: Cleanup en unmount del componente principal
  useEffect(() => {
    return () => {
      // Solo limpiar la suscripci√≥n, no destruir el manager
    };
  }, []);

  return {
    user: authManager.state.user,
    loading: authManager.state.loading,
    error: authManager.state.error,
    isInitialized: authManager.state.isInitialized,
    isAuthenticated: !!authManager.state.user,
    register: (userData: UserRegistrationVo) => authManager.register(userData),
    login: (email: string, password: string) => authManager.login(email, password),
    logout: () => authManager.logout(),
    checkIsGoogleUser: () => authManager.checkIsGoogleUser(),
    
    // ‚úÖ NUEVO: M√©todo de emergencia para estabilizar
    forceStabilize: () => authManager.forceStabilize(),
  };
};